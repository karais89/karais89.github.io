<!doctype html>
<html lang="ko" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">프로그래밍의 정석 요약 | Lonpeach Tech</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://tech.lonpeach.com/2018/10/26/the-pinnacle-of-programming-summary"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="프로그래밍의 정석 요약 | Lonpeach Tech"><meta data-rh="true" name="description" content="프로그래밍의 정석 요약"><meta data-rh="true" property="og:description" content="프로그래밍의 정석 요약"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2018-10-26T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/karais89"><meta data-rh="true" property="article:tag" content="programming"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://tech.lonpeach.com/2018/10/26/the-pinnacle-of-programming-summary"><link data-rh="true" rel="alternate" href="https://tech.lonpeach.com/2018/10/26/the-pinnacle-of-programming-summary" hreflang="ko"><link data-rh="true" rel="alternate" href="https://tech.lonpeach.com/2018/10/26/the-pinnacle-of-programming-summary" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://UJCTEGEXU7-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/rss.xml" title="Lonpeach Tech RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Lonpeach Tech Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-59335977-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>


<link rel="search" type="application/opensearchdescription+xml" title="Lonpeach Tech" href="/opensearch.xml">
<link rel="icon" href="/img/docusaurus.png">
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="rgb(37, 194, 160)"><link rel="stylesheet" href="/assets/css/styles.448cd76c.css">
<link rel="preload" href="/assets/js/runtime~main.6c5e61e9.js" as="script">
<link rel="preload" href="/assets/js/main.6d90619a.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div role="region" aria-label="본문으로 건너뛰기"><a href="#" class="skipToContent_fXgn">본문으로 건너뛰기</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title text--truncate">Lonpeach Tech</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/">Blog</a><a class="navbar__item navbar__link" href="/docs/intro">Tutorial</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/karais89/karais89.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="검색"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">검색</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="최근 블로그 문서 둘러보기"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2022/03/16/jekyll-font">코딩용 고정폭 폰트 Cascadia Code 사용기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/welcome">Welcome</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2021/06/21/FastAPI-Getting-Started-3">FastAPI 입문 3 - 튜토리얼 - 도입</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2021/06/20/FastAPI-Getting-Started-2">FastAPI 입문 2 - 연습 예제</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2021/06/18/FastAPI-Getting-Started-1">FastAPI 입문 1 - 특징 및 환경설정</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">프로그래밍의 정석 요약</h1><div class="container_mt6G margin-vert--md"><time datetime="2018-10-26T00:00:00.000Z" itemprop="datePublished">2018년 10월 26일</time> · <!-- -->약 50분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/karais89" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/karais89.png" alt="karais89"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/karais89" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">karais89</span></a></div><small class="avatar__subtitle" itemprop="description">Game Developer</small></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><p><a href="/2018/10/26/the-pinnacle-of-programming">프로그래밍의 정석</a> 요약</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="책에서의-용어-설명">책에서의 용어 설명<a class="hash-link" href="#책에서의-용어-설명" title="제목으로 바로 가기">​</a></h2><ul><li>모듈<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">- 함수나 변수를 어떤 책임 단위로 묶어낸 것은 모듈로 통일한다.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>연관성이 높은 코드를 한데 묶었다는 의미에서 클래스, (함수나 변수를 모은 하나의) 파일, 컴포넌트, 부품, 라이브러리라는 용어도 있는데, 이 용어들을 모두 포함해서 모듈이라고 부른다.</li><li>함수<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">- 코드 일부를 떼어내어 호출할 수 있게 만든 것은 함수로 통일한다.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>루틴, 함수, 프로시저, 메시지, 메서드, 멤버 함수 등 용어는 세부적으로 나뉘는데, 이 용어들은 모두 포함해서 함수라고 한다.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="책에서의-참고-서적">책에서의 참고 서적<a class="hash-link" href="#책에서의-참고-서적" title="제목으로 바로 가기">​</a></h2><ul><li><a href="http://www.yes24.com/24/goods/16928943?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">맨먼스 미신</a></li><li>소프트웨어 개발은 어째서 어려운가?-맨먼스 미신을 뛰어넘어 (국내 미출간)</li><li><a href="http://www.yes24.com/24/Goods/1418676?Acode=101" target="_blank" rel="noopener noreferrer">소프트웨어 공학의 사실과 오해 - 우리가 미처 알지 못한</a></li><li><a href="http://www.yes24.com/24/Goods/44130507?Acode=101" target="_blank" rel="noopener noreferrer">CODE COMPLETE - 소프트웨어 구현에 대한 실무서</a></li><li><a href="http://www.yes24.com/24/goods/39497990?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">클린 소프트웨어</a></li><li><a href="http://www.yes24.com/24/goods/7130112?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">프로그래머가 알아야 할 97가지</a></li><li><a href="http://www.yes24.com/24/goods/5312881?scode=032&amp;OzSrank=2" target="_blank" rel="noopener noreferrer">도메인 주도 설계</a></li><li><a href="http://www.yes24.com/24/goods/2126201?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">익스트림 프로그래밍</a></li><li><a href="http://www.yes24.com/24/goods/12501565?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">실용주의 프로그래머</a></li><li><a href="http://www.yes24.com/24/goods/1405887?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">Art of UNIX Programming</a></li><li><a href="http://www.yes24.com/24/goods/4839616?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">소프트웨어 아키텍트가 알아야 할 97가지</a></li><li><a href="http://www.yes24.com/24/goods/3530189?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">능률적인 프로그래머 - 프로그래머 생산성의 비밀</a></li><li><a href="http://www.yes24.com/24/goods/64586851?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">레거시 코드 활용 전략</a></li><li><a href="http://www.yes24.com/24/goods/2875222?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">지속적인 통합 - 소프트웨어 품질을 높이고 위험을 줄이기</a></li><li><a href="http://www.yes24.com/24/goods/6006038?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">좋은 코드를 작성하는 기술-읽기 쉽고 유지보수가 쉬운 프로그래밍 작성법</a></li><li>구체와 추상-세계가 달리 보이는 지성의 구조(국내 미출간)</li><li><a href="http://www.yes24.com/24/goods/3696323?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">패턴, Wiki 그리고 XP - 시간을 초월한 창조의 원칙</a></li><li><a href="http://www.yes24.com/24/goods/290687?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">EXTREME PROGRAMMING INSTALLED - XP 도입을 위한 실전 입문</a></li><li><a href="http://www.yes24.com/24/goods/2664688?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">애자일 프랙티스 - 빠르고 유연한 개발자의 실천 가이드</a></li><li><a href="http://www.yes24.com/24/goods/2716009?scode=032&amp;OzSrank=2" target="_blank" rel="noopener noreferrer">CODE CRAFT - 뛰어난 코드 작성을 위한 실천 지침</a></li><li>커누스 교수의 프로그래밍론(국내 미출간)</li><li><a href="http://www.yes24.com/24/goods/5646494?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">프로젝트 관리자가 알아야 할 97가지</a></li><li><a href="http://www.yes24.com/24/goods/6692314?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">읽기 쉬운 코드가 좋은 코드다 - 더 나은 코드를 작성하는 간단하고 실전적인 테크닉</a></li><li>켄트 백의 스몰토크 가이드와 패턴 - 심플한 디자인을 위한 핵심 노트(국내 미출간)</li><li><a href="http://www.yes24.com/24/goods/2824034?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">켄트 백의 구현 패턴</a></li><li><a href="http://www.yes24.com/24/goods/14752528?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">패턴을 활용한 리팩토링</a></li><li>객체지향 입문 제2판 - 원칙과 개념(국내 미출간)</li><li><a href="http://www.yes24.com/24/goods/1778966?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">HEAD FIRST DESIGN PATTERNS</a></li><li>UML과 디자인 패턴 활용</li><li>프로그래밍의 모든 것 - C의 창시자 브라이언 커니건</li><li><a href="http://www.yes24.com/24/goods/384554?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">알기 쉬운 디자인 패턴</a></li><li>마쓰모토 유키히로의 코드의 세계 - 최간 프로그래머가 되는 14가지 사고방식</li><li>네이밍의 규칙과 비법(국내 미출간)</li><li><a href="http://www.yes24.com/24/Goods/11681152?Acode=101" target="_blank" rel="noopener noreferrer">클린 코드</a></li><li>커누스 교수의 프로그래밍론(국내 미출간)</li><li><a href="http://www.yes24.com/24/goods/2813069?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">패턴 지향 소프트웨어 아키텍처</a></li><li>조직 패턴(국내 미출간)</li><li>UNIX MAGAZINE Classic with DVD(국내 미출간)</li><li><a href="http://www.yes24.com/24/goods/11101558?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">코딩을 지탱하는 기술 - 원리로 깨우치는 프로그래밍 기법</a></li><li>구체와 추상 - 세계가 달라 보이는 지성의 구조(국내 미출간)</li><li>관점 지향 프로그래밍 입문 - Java 객체지향에서 AspectJ 프로그래밍으로(국내 미출간)</li><li>객체지향 프로그래밍 입문(국내 미출간)</li><li>객체지향 프로그래머가 다음으로 읽는 책 - 스칼라로 배우는 함수뇌 입문(국내 미출간)</li><li><a href="http://www.yes24.com/24/goods/8315789?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">UML을 활용한 객체지향 분석 설계</a></li><li>비기능 요구사항 정의 가이드라인(국내 미출간)</li><li>테크니컬 엔지니어 정보 보안 표준 교분(국내 미출간)</li><li>소프트웨어 품질 지식 체계 가이드 - SQuBOK Guide 제2판(국내 미출간)</li><li>어떻게 문제를 풀 것인가 - 수학적 사고방식</li><li>UNIX라는 사고방식 - 설계 사상과 철학(국내 미출간)</li><li>효과적 프로그램 개발 기법(국내 미출간)</li><li>소프트웨어의 복합 구조화 설계(국내 미출간)</li><li><a href="http://www.yes24.com/24/goods/5170353?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">웹 개발자를 위한 웹을 지탱하는 기술 - HTTP, URI, HTML 그리고 REST</a></li><li><a href="http://www.yes24.com/24/goods/2836913?scode=032&amp;OzSrank=6" target="_blank" rel="noopener noreferrer">RESTful 웹 서비스 - 웹 서비스의 진화</a></li><li><a href="http://www.yes24.com/24/goods/22384677?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">엔터프라이즈 애플리케이션 아키텍처 패턴 - 엔터프라이즈 애플리케이션 구축을 위한 객체지향 설계의 원리와 기법</a></li><li><a href="http://www.yes24.com/24/goods/29343536?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">관계형 데이터베이스 실전 입문 - 원리부터 배우는</a></li><li><a href="http://www.yes24.com/24/goods/2666357?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">Java 언어로 배우는 리팩토링 입문</a></li><li><a href="http://www.yes24.com/24/goods/7951038?scode=032&amp;OzSrank=2" target="_blank" rel="noopener noreferrer">리팩토링 - 코드 품질을 개선하는 객체지향 사고방식</a></li><li>애자일 개발의 예술 - 조직을 성공으로 이끄는 익스트림 프로그래밍(국내 미출간)</li><li>코가이 단의 시스템 진화론(국내 미출간)</li><li><a href="http://www.yes24.com/24/goods/44164?scode=032&amp;OzSrank=3" target="_blank" rel="noopener noreferrer">Perl 프로그래밍</a></li><li><a href="http://www.yes24.com/24/goods/2121283?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">THE ART OF PROJECT MANAGEMENT - 마음을 움직이는 프로젝트 관리</a></li><li><a href="http://www.yes24.com/24/goods/14283616?scode=032&amp;OzSrank=2" target="_blank" rel="noopener noreferrer">Effective Java</a></li><li><a href="http://www.yes24.com/24/goods/11686161?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">프로그래밍 심리학</a></li><li><a href="http://www.yes24.com/24/goods/39114584?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">성공하는 사람들의 7가지 습관</a></li><li><a href="http://www.yes24.com/24/goods/12246033?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">테스트 주도 개발</a></li><li>사상 최강의 논리 퍼즐 - 핵심을 간파하는 힘을 기르는 60문제(국내 미출간)</li><li>효과적인 프로그램 개발 기법(국내 미출간)</li><li><a href="http://www.yes24.com/24/goods/2657930?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">성공적인 소프트웨어 개발 프로젝트를 위한 실용 가이드</a></li><li>객체지향 입문 제2판 - 원칙과 개념(국내 미출간)</li><li><a href="http://www.yes24.com/24/goods/1469763?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">조엘 온 소프트웨어 - 유쾌한 오프라인 블로그</a></li><li>시스템 사고 입문(국내 미출간)</li><li><a href="http://www.yes24.com/24/goods/1780552?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">니코마코스 윤리학</a></li><li>입문 철학으로서의 불교(국내 미출간)</li><li>포커스 리딩 - 한 권에 10분 속도로 열 배의 효과를 내는 장점 일색 독서술(국내 미출간)</li><li>안티패턴 - 소프트웨어 위독 환자 구출(국내 미출간)</li><li>린 소프트웨어 개발과 조직 개혁(국내 미출간)</li><li><a href="http://www.yes24.com/24/goods/11141565?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">불가사의 심리학 - 알기 쉽게 배우는 과학적 사고의 기술</a></li><li>엔트로피를 둘러싼 모험 - 초보자를 위한 통계 열역학(국내 미출간)</li><li><a href="http://www.yes24.com/24/goods/30468592?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">디자이너가 아닌 사람들을 위한 디자인북</a></li><li>교양으로서의 성서(국내 미출간)</li><li>Code Simplicity - 소프트웨어 간결성을 지키는 사실과 법칙, 그리고 진리</li><li><a href="http://www.yes24.com/24/goods/6185848?scode=032&amp;OzSrank=1" target="_blank" rel="noopener noreferrer">프로그래머, 열정을 말하다</a></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="원리-원칙-리스트">원리 원칙 리스트<a class="hash-link" href="#원리-원칙-리스트" title="제목으로 바로 가기">​</a></h2><ul><li>프로그래밍에 은제 탄환은 없다<ul><li>프로그래밍에 마법 같은 해결책은 없다.</li></ul></li><li>코드는 설계서다</li><li>코드는 반드시 변경된다<ul><li>코드가 변경된다는 사실은 코드를 작성할 때 다양한 판단, 선택, 결단을 하는 데 있어서 최우선으로 고려해야 한다.</li></ul></li><li>KISS (Keep It Simple, Stupid / Keep It Short and Simple)<ul><li>간단하게 해라, 어리석은 녀석아 / 간결하고 단순하게 해라</li><li>코드를 작성할 때는 최우선 가치를 단순성과 간결성에 둔다.</li></ul></li><li>DRY (Don&#x27;t Repeat Yourself 중복하지 마라)<ul><li>똑같은 코드를 중복해서 작성해서는 안된다</li></ul></li><li>YAGNI (You Aren&#x27;t Going to Need it 그것은 분명 필요 없어진다)<ul><li>정말로 필요해졌을 때 필요한 코드만을 작성한다는 방침으로 프로그래밍에 임해야 한다</li></ul></li><li>PIE (Program Intently and Expressively 의도를 표현해서 프로그래밍하라)<ul><li>코드를 작성할 때는 의도를 명확하게 표현해야 한다는 점이 중요하다</li><li>코드는 컴파일러가 아닌 사람이 읽기 위한 것이기 때문이다</li><li>코드를 작성할 때는 작성하기 쉬움 보다는 읽기 쉬움을 중시하자.</li></ul></li><li>SLAP (Single Level of Abstraction Principle 추상화 수준의 통일)<ul><li>추상화 단계를 분리할 때는 기능의 복잡도에 따라 여러 계층으로 분리한다.</li></ul></li><li>OCP (Open-Closed Principle 개방-폐쇄의 원칙)<ul><li>코드는 확장에 대해서 열려 있고 수정에 대해서 닫혀 있는 2가지 속성을 동시에 충족하도록 설계한다</li><li>확장에 대해서 열려 있다는 말은 코드의 동작을 확장할 수 있다는 의미이다.</li><li>수정에 대해서 닫혀 있다는 말은 코드의 동작을 확장하더라도 그 밖의 코드는 전혀 영향을 받지 않는다는 의미이다.</li><li>코드에 인터페이스를 사용한다</li><li>OCP의 대표적인 패턴 (스트레티지, 옵저버, 탬플릿 메서드,데코레이터)</li></ul></li><li>명명이 중요하다<ul><li>이름을 붙이는 행위와 그런 과정을 통해 생겨난 이름 자체에 모두 중요한 가치가 있다.</li><li>다음 사항에 주의한다.<ul><li>이름에는 더 많은 정보를 담도록 한다. 이름을 짧은 주석이라고 생각한다.</li><li>이름을 오해받지 않도록 주의한다. 다른 의미와 혼동되지 않도록 몇 번이고 자문자답해야 한다.</li><li>이름이 효과와 목적을 설명하도록 한다.</li><li>이름은 발음 가능한 것으로 한다</li><li>이름은 검색 가능하도록 붙인다.</li></ul></li></ul></li><li>프로그래밍 이론<ul><li>최고의 코드란 확장 방법이 다양하게 존재하고 불필요한 요소가 존재하지 않으며 읽기 쉽고 이해하기 쉬운 코드다.<ul><li>의사소통<ul><li>코드는 남에게 보여주는 문서다. 그리고 문서의 본질은 의사소통 수단이다.        </li><li>프로그래밍에서 의사소통이 원할하다는 것은 코드를 읽은 사람이 코드를 이해할 수 있고, 코드를 수정할 수 있으며, 코드를 사용할 수 있다는 뜻이다.</li></ul></li><li>단순함<ul><li>코드가 단순하다는 것은 코드에서 불필요한 복잡성이 제거된 상태를 가리킨다.</li></ul></li><li>유연성<ul><li>코드에서 유연성이란 코드 변경이 용이함을 뜻한다.</li></ul></li></ul></li></ul></li><li>결과의 국소화<ul><li>변경이 미치는 영향이 국소에 머무르도록 코드를 구성한다.</li></ul></li><li>반복의 최소화<ul><li>반복이란 중복을 뜻한다. 즉 중복을 최대한 제거한다는 뜻이다.</li></ul></li><li>로직과 데이터의 일체화<ul><li>로직과 해당 로직이 조작하는 데이터를 서로 가까이에 배치시키는 것을 뜻한다.</li><li>여기서 가까이란 같은 함수 혹은 같은 모듈이며 가까우면 가까울수록 좋은 코드다.</li></ul></li><li>대칭성<ul><li>대칭성이란 일반적으로 어떤 변환에도 변하지 않는 성질을 가리킨다.</li></ul></li><li>선언형의 표현<ul><li>선언형의 표현이란 코드의 의도를 전하고자 할 때 가능한 한 명령형보다는 선언형으로 표현하는 것을 뜻한다.</li><li>명령형 프로그램은 문제의 해법, 즉 자료구조와 알고리즘을 기술한다.</li><li>반면에 선언형 프로그래밍은 문제의 정의, 즉 해결해야 할 문제의 성질이나 이때 충족해야 할 제약을 기술한다.</li></ul></li><li>변경빈도<ul><li>변경 빈도란 코드를 수정하는 시점이 같다는 의미이다. 즉 변경 이유가 같다는 뜻이다.</li><li>같은 시점에 변경되는 요소는 같은 곳에 두고, 다른 시점에 변경되는 요소는 다른 곳에 분리해 두도록 한다.</li></ul></li><li>아키텍처 기본 기법<ul><li>소프트웨어 아키텍처를 적절하게 구축하는 데 필요한 기초 원리</li><li>추상<ul><li>추상이란 개념적으로 명확한 선 긋기를 수행하는 것이다.</li><li>추상은 사상과 일반화라는 2가지 관점에서 정리된다.<ul><li>사상 : 복잡한 대상의 몇 가지 성질을 버리고 특정한 성질에 주목하는 것</li><li>일반화 : 구체적인 대상으로부터 공통 성질을 추출해서 더욱 범용적인 개념으로 정싱화하는 것</li></ul></li></ul></li><li>캡슐화<ul><li>관계성이 강한 데이터와 로직을 모듈이라는 껍질로 감싸는 것을 캡슐화라고 부른다.</li></ul></li><li>정보 은닉<ul><li>모듈의 구현을 해당 모듈을 사용하는 클라이언트로부터 은닉한다.</li></ul></li><li>패키지화<ul><li>모듈을 의미 있는 단위로 모은 다음 그룹화한다.</li></ul></li><li>관심의 분리<ul><li>관심이란 소프트웨어의 기능이나 목적을 뜻한다.</li><li>관심을 분리한다는 것은 각각의 관심에 관련된 코드를 모아 독립된 모듈로 만들어 다른 코드로부터 분리한다는 뜻이다.</li><li>대표적인 패턴 MVC</li></ul></li><li>충족성, 완전성, 프리미티브성(원시성, 순서성)<ul><li>모듈이 담당하는 추상에 대한 표현은 충분하고 완전하며 프리미티브여야 한다.</li><li>충족성<ul><li>모듈이 표현하고자 하는 추상이 그것을 전하기에 충분한지를 뜻한다.</li><li>모듈이 컬렉션을 표현하고 있을 때 remove가 제공된다고 해도 add가 제공되지 않는다면 컬렉션이라는 점을 전하기에는 불충분하다.</li></ul></li><li>완전성<ul><li>모듈이 표현하고자 하는 추상이 모든 특징을 갖추고 있는지를 뜻한다.</li><li>모듈이 컬렉션을 표현하고 있을 때 요소의 개수를 구하는 size가 제공되지 않는다면 완전하다고 할 수 없다.</li></ul></li><li>프리미티브성<ul><li>모듈이 표현하고자 하는 추상이 모두 순수한지 아닌지를 의미한다.</li><li>모듈이 컬렉션을 표현하고 있을 때 아이템을 1개 추가하는 add가 제공된다면 아이템을 10개 추가하는 add10은 필요하지 않다.</li></ul></li></ul></li><li>정책과 구현의 분리<ul><li>모듈은 정책 혹은 구현을 다룬다. 다만 하나의 모듈에서 양쪽 모두를 다루어서는 안 된다.</li></ul></li><li>인터페이스와 구현의 분리<ul><li>모듈은 인터페이스 파트와 구현 파트 2개의 분리된 부분으로 구성한다.<ul><li>인터페이스 파트 : 모듈이 가진 기능을 정의하고 모듈의 사용 방법을 정하는 부분 클라이언트에서 접근할 수 있는 함수의 원형으로 구성된다.</li><li>구현 파트 : 구현 파트란 모듈이 가진 기능을 실현하는 코드 부분. 모듈이 내부에서 사용하는 로직과 데이터가 포함된다. 구현 파트는 클라이언트에서 접근할 수 없다.</li></ul></li><li>사용자는 인터페이스만 알면 된다.</li></ul></li><li>참조의 단일성<ul><li>모듈의 요소에 관한 선언과 정의는 1회로 제한한다</li><li>정의가 1회라는 말은 예를 들어 변수값을 초기화했다면 이후 값은 변경하지 않는다는 뜻이다.</li><li>이렇게 하면 변수값의 변화를 추적하지 않아도 되므로 직관적인 코드가 된다.</li></ul></li><li>분할 정복<ul><li>그대로는 해결하기 어려운 커다란 문제는 여러 개의 작은 문제로 분할해서 개별적으로 해결한다</li></ul></li></ul></li><li>아키텍처 비기능 요구사항<ul><li>정의: 기능 외적인 면 전반에 관한 요구사항</li><li>변경 용이성<ul><li>변경 용이성이란 해당 소프트웨어를 얼마나 쉽게 개선할 수 있는지에 대한 능력</li><li>해당 소프트웨어를 쉽게 수정할 수 있는지, 쉽게 확장할 수 있는지, 쉽게 재조직할 수 있는지, 쉽게 다른 플랫폼으로 이식할 수 있는지 등의 능력</li></ul></li><li>상호 운용성<ul><li>상호 운용성이란 소프트웨어가 다른 소프트웨어와 정보를 주고받을 수 있는 능력</li></ul></li><li>효율성<ul><li>효율성이란 소프트웨어가 실행되면서 동반되는 리소스 사용에 있어서 적절한 성능을 끌어내는 능력</li><li>시간 효율성</li><li>자원 효율성</li></ul></li><li>신뢰성<ul><li>신뢰성이란 소프트웨어가 예외적인 상황 혹은 예기치 못한 방법이나 부정한 방법으로 사용된 상황에서도 기능을 유지하는 능력</li></ul></li><li>테스트 용이성<ul><li>테스트 용이성이란 소프트웨어에 대해 효과적이면서 효율적으로 테스트를 수행하는 능력</li></ul></li><li>재사용성<ul><li>재사용성이란 소프트웨어를 전체가 됐든 일부가 됐든 다른 소프트웨어 개발에 재사용하는 능력을 뜻한다.</li></ul></li></ul></li><li>7가지 설계 원리<ul><li>7가지 설계 원리란 결함을 만들어 내지 않기 위해 고려해야 할, 코드 구조상의 7가지 핵심 관점을 뜻한다.</li><li>단순 원리<ul><li>단순 원리란 단순함을 중시한다는 원리다.</li><li>극단적으로 말하자면 프로그래밍 생초보도 읽을 수 있을 만큼 일관되고 단순한 코드를 작성해야 한다.</li></ul></li><li>동형 원리<ul><li>동형 원리란 형태를 중시한다는 원리다.</li><li>어떤 모듈에서 다루는 숫자의 단위, 공개 함수의 파라미터 수, 사용 순서 등이 통일된다는 것을 의미한다.</li><li>일관성 있는 코드를 작성하자.</li></ul></li><li>대칭 원리<ul><li>대칭 원리란 형태의 대칭성을 중시한다는 원리다.</li><li>어떤 플래그가 참일 때의 처리가 있다면 거짓일 때의 처리도 있어야 한다.</li><li>명명의 대칭성에도 신경 쓰자. set/get, start/stop, begin/end, push/pop 등</li></ul></li><li>계층 원리<ul><li>계층 원리란 구조의 계층성을 중시한다는 원리다.</li><li>리소스를 할당했다면 같은 계층에서 리소스를 해제해야 한다.</li><li>배타 제어를 위해 플래그를 걸었다면 같은 계층에서 플래그를 해제해야 한다.</li></ul></li><li>선형 원리<ul><li>선형 원리란 처리의 직선적 흐름을 중시한다는 원리다.</li><li>오류는 복잡한 조건문이나 반복문에서 많이 발생한다.</li><li>위에서 아래를 향해 한 방향으로 내려가는 코드 흐름은 단순명쾌하고 이해하기 쉽다.</li><li>분기가 적은 코드를 작성한다.</li></ul></li><li>명증 원리<ul><li>명증 원리란 로직의 명증성을 중시한다는 원리다.</li><li>명증성이란 확실하게 증명한다는 의미다.</li></ul></li><li>안전 원리<ul><li>안전 원리란 안전성을 중시한다는 원리다.</li><li>필연성이 없는 곳이나 모호한 곳은 안전한 쪽으로 설계하고 프로그래밍해 두는 것이다.</li></ul></li></ul></li><li>UNIX 사상<ul><li>UNIX 사상이란 뛰어난 프로그래밍을 수행할 수 있는, 경험에 기반을 두고 있는 실천적인 노하우의 집합이다.</li><li>모듈화의 원칙<ul><li>명료한 인터페이스로 결합한 단순한 모듈들로 소프트웨어를 조립해야 한다</li><li>코드 중에 관계성이 높은 요소를 모아 모듈을 작성한다</li><li>모듈이 제공하는 인터페이스는 불필요한 것은 제외하고 가장 적게 만들자</li><li>모듈의 구성 요소는 관계성이 높은 것만 모아 놓도록 한다.</li></ul></li><li>명확성의 원칙<ul><li>코드는 교모하게가 아니라 명확하게 작성해야 한다</li></ul></li><li>구성의 원칙<ul><li>소프트웨어는 다른 소프트웨어와 조합할 수 있도록 만든다</li></ul></li><li>분리의 원칙<ul><li>메커니즘에서 정책을 분리한다.</li><li>정책<ul><li>해당 소프트웨어의 전제에 종속되는 부분</li><li>비즈니스 로직이나 사용자 인터페이스</li></ul></li><li>메커니즘<ul><li>해당 소프트웨어의 전제에 종속되지 않는 독립된 부분</li><li>그래픽 처리의 래스터 변환 등 엔진 역할을 수행하는 부분</li></ul></li></ul></li><li>단순성의 원칙<ul><li>코드가 단순해지도록 설계한다</li></ul></li><li>절약의 원칙<ul><li>큰 코드는 작성하지 않도록 한다</li><li>코드의 분량이 큰 것과 코드 내부의 복잡도가 큰 양쪽을 의미한다.</li></ul></li><li>투명성의 원칙<ul><li>소프트웨어의 동작을 바깥에서 이해하기 쉽게 보이도록 설계한다</li></ul></li><li>안전성의 원칙<ul><li>일반적인 조건뿐만 아니라 예상외의 조건에서도 적절하게 동작되는 것</li></ul></li><li>표현성의 원칙<ul><li>코드에서 정보를 표현할 때는 로직이 아닌 데이터에 모아 작성하는 방식으로 한다</li></ul></li><li>충격 최소의 원칙<ul><li>인터페이스는 사용하는 사람이 상상하는 형태대로 동작하도록 설계한다</li></ul></li><li>침묵의 원칙<ul><li>소프트웨어는 표시를 최소한으로 줄이고 과묵하게 작업을 수행해야 한다</li></ul></li><li>복구의 원칙<ul><li>소프트웨어 동작 중 오류 복구에 실패했다면 처리를 계속해서는 안 된다</li><li>나아가 해당 오류는 가능하면 한눈에 띄도록 발생시킨다</li></ul></li><li>경제성의 원칙<ul><li>프로그래머의 시간을 절햑해야 한다</li><li>시간 낭비가 되는 리스트</li><li>빈약한 하드웨어</li><li>사용 소프트웨어에 대한 제한</li><li>환경에 관한 규제와 제한</li></ul></li><li>생성의 원칙<ul><li>코드를 작성하기 위한 코드를 작성한다</li><li>코드 생성기를 만든다</li></ul></li><li>최적화의 원칙<ul><li>빠른 코드보다 바른 코드</li></ul></li><li>다양성의 원칙<ul><li>소프트웨어에서는 선택의 다양성을 수용한다</li><li>소프트웨어에 관한 모든 상황에서 유일하게 바른 방법은 존재하지 않는다</li><li>더 좋은 방법을 계속 찾는다</li></ul></li><li>확장성의 원칙<ul><li>확장성을 고려한 설계를 수행한다</li></ul></li></ul></li><li>UNIX 철학<ul><li>UNIX적인 사고방식</li><li>작은 것이 아름답다<ul><li>작게 만들고 작게 유지하도록 한다 </li><li>장점 <ul><li>이해가 쉽다</li><li>보수가 쉽다</li><li>머신 자원에 부담을 주지 않는다</li><li>다른 소프트웨어와 조합하기 쉽다</li></ul></li></ul></li><li>한 번에 하나의 작업<ul><li>하나의 소프트웨어에는 하나의 작업만 제대로 시킨다</li><li>가장 좋은 소프트웨어란 생애 중에 단 하나의 작업만을 제대로 완수하는 소프트웨어다</li></ul></li><li>즉시 프로토타입 진행<ul><li>가능한 한 빨리 프로토타입을 작성한다</li><li>어떤 아이디어가 성공할 것 같은지, 눈에 보이는 형태로 현실화 할 수 있는지를 확인하려면 시험 삼아 만들어보는 방법이 가장 좋다</li></ul></li><li>효율성보다 이식성<ul><li>소프트웨어 설계는 선택의 연속이다</li><li>이식성과 개발 효율성이라는 이율배반적인 선택을 해야되는데 이때는 이식성을 우선시해야 한다</li></ul></li><li>데이터는 텍스트로<ul><li>데이터는 텍스트 파일로 저장한다</li><li>데이터의 이식성도 중시해야 한다</li><li>거의 모든 면에서 바이너리 파일보다 뛰어나다</li></ul></li><li>레버리지 소프트웨어<ul><li>레버리지(지렛대)</li><li>코드를 대량으로 작성하는 가장 좋은 방법은 빌려 오는 것이다</li><li>각각이 단일 기능이며 단일 가치에 집중하는 작은 소프트웨어를 작성하자</li></ul></li><li>셸 스크립트 활용<ul><li>셸 스크립트를 통해 지렛대 효과와 이식성을 높인다</li><li>셸 스크립트는 이식성이 높다</li></ul></li><li>대화형 인터페이스 회피<ul><li>대화형 인터페이스 회피</li><li>지나친 대화형 인터페이스를 피하도록 한다</li><li>대화형 인터페이스의 문제<ul><li>소프트웨어별로 독자적인 대화 방법을 기억해야 한다</li><li>소프트웨어끼리 대화할 수 없다</li><li>대기 시간이 많아진다</li><li>입력 부분에 대한 해석 코드가 많아지고 흉해진다</li><li>큰 것이 아름다운 접근법으로 변질된다</li></ul></li></ul></li><li>필터화<ul><li>모든 소프트웨어를 필터로 설계한다</li><li>필터란 입력 스트립을 데이터로 받아들여 어떤 형태로든 가공한 다음 가공된 데이터를 출력 스트림으로 송출하는 것이다</li><li>소프트웨어의 본질은 데이터를 처리하는 것이지 생성하는 것이 아니다</li></ul></li></ul></li><li>UNIX 철학과 작은 정리<ul><li>환경 커스터마이즈</li><li>작고 가벼운 커널</li><li>소문자 사용</li><li>자연 보호</li><li>침묵은 금</li><li>병령 사고</li><li>부품 협력</li><li>90%의 해</li><li>열등해야 뛰어나다</li><li>계층 지향</li></ul></li><li>응집도<ul><li>응집도란 모듈에 포함된 기능의 순수함을 나타내는 척도로, 모듈의 강도를 측정하는 단위다</li><li>응집도의 단계는 7단계다.</li><li>단계가 높을수록(숫자가 클수록) 순수하고 강하며 좋은 모듈이다.</li><li>1단계: 암합적 강도<ul><li>모듈 내 요소 간 특별한 관계가 인정되지 않는다</li><li>암합이란 우연히 요소가 일치한다는 의미다</li></ul></li><li>2단계: 논리적 강도<ul><li>어떤 기능을 추상적으로 파악해서 모은 것이다</li></ul></li><li>3단계: 시간적 강도<ul><li>특정 시점에 연속해서 실행되는 여러 개의 기능을 하나의 모듈로 모은 것이다.</li></ul></li><li>4단계: 순서적 강도<ul><li>문제를 처리하기 위해  관계된 여러 개의 기능 중 몇 가지를 실행한다</li></ul></li><li>5단계: 연락적 강도<ul><li>기본적으로 순서적 강도의 특성을 갖는다</li><li>순서적 강도와의 차이점은 모듈 내 기능 사이에서 데이터를 교환(연락)하거나 같은 데이터를 참조한다는 점이다.</li></ul></li><li>6단계: 정보적 강도<ul><li>특정 자료구조를 다루는 여러 개의 기능을 하나의 모듈로 모은 것이다.</li></ul></li><li>7단계: 기능적 강도<ul><li>모듈 내의 모든 명령이 하나의 역할(기능)을 실행하기 위해 서로 관련된 모듈로, 응집도가 가장 높은 모듈이다</li></ul></li></ul></li><li>결합도<ul><li>결합도란 모듈끼리 갖는 관계의 밀접함을 나타내는 척도로, 어떤 결합의 굵기를 측정하는 단위다</li><li>결합도의 수준은 6단계다.</li><li>단계가 높을수록(숫자가 클수록) 관계가 약하고 느슨한 결합이며 좋은 모듈이라고 할 수 있다</li><li>1단계: 내용 결합<ul><li>한 모듈과 다른 모듈이 일부를 공유하는 모듈 결합 방식</li><li>다른 모듈 내의 외부에 선언되지 않은 데이터를 직접 참조하거나 명령의 일부를 공유하는 경우</li></ul></li><li>2단계: 공통 결합<ul><li>공통 영역에 정의된 데이터를 몇 개 모듈이 공동으로 사용하는 모듈 결합 방식</li><li>공통 영역에 정의된 데이터란 이른바 전역 변수를 말한다</li></ul></li><li>3단계: 외부 결합<ul><li>외부에 선언된 데이터를 공유하는 모듈 결합 방식</li><li>외부에 선언된 데이터란 예를 들면 public으로 선언된 변수를 말한다</li></ul></li><li>4단계: 제어 결합<ul><li>호출하는 모듈 쪽에서 호출받는 모듈의 제어를 지시하는 데이터를 파리미터로 넘겨주는 모듈 결합 방식</li></ul></li><li>5단계: 스탬프 결합<ul><li>공통 영역에 없는 자료구조를 2개의 모듈에서 교환하는 모듈 결합 방식</li></ul></li><li>6단계: 데이터 결합<ul><li>모듈 간의 인터페이스로 스칼라형 데이터 요소만을 파라미터로 교환하는 모듈 결합 방식</li><li>모듈 A는 모듈 B의 입력으로 X를 넘겨주면 출력으로 Y를 받는다는 점만 알고 있다</li></ul></li><li>느슨한 결합을 지향하자<ul><li>데이터는 가능한 한 파라미터로 넘겨준다</li><li>데이터는 가능한 한 전역 변수로 두지 않는다. 특정 시점에만 필요한 데이터라면 지역 변수로 두도록 한다</li><li>넘겨주는 값에 따라 동작이 바뀌는 코드를 작성하지 않는다. 예를 들어 파라미터로 건네받는 플래그의 내용이 A라면 추가, D라면 삭제하는 식의 함수는 결합도가 강해진다</li></ul></li></ul></li><li>직교성<ul><li>직교는 기하학에서 그래프의 좌표축과 같이 직각으로 교차하는 2개의 선분이 갖는 성질이다</li><li>코드 간에는 독립성과 분리성을 갖도록 만든다</li><li>2개 이상의 코드 덩어리가 있으면서 한쪽을 변경해도 다른 쪽에 영향을 주지 않는다면 해당 코드는 직교하고 있다</li><li>직교하고 있는 코드는 변경에 강한 코드다</li><li>장점<ul><li>생산성 향상</li><li>위험 경감</li></ul></li></ul></li><li>가역성<ul><li>가역이란 어떤 변화가 발생해도 특정 조건을 가하면 원래 상태로 돌아오는 성질</li></ul></li><li>코드의 구린내<ul><li>코드의 구린내란 코드 중에서 이해하기 어렵고, 수정하기 어렵고, 확장하기 어렵다고 느껴지는 부분</li><li>프로그래머는 이런 구린내를 식별해 내서 적절한 코드로 개선해야 한다</li><li>코드의 구린내 징후<ul><li>자주 보인다<ul><li>똑같은 코드가 여기저기 흩어져 있는 상태</li></ul></li><li>너무 길다<ul><li>함수가 너무 길어 스크롤을 몇 번이나 내려도 끝나지 않는 상태</li></ul></li><li>너무 크다<ul><li>모듈이 너무 컷거 관리 불능인 상태</li><li>모듈이 너무 크다는 말은 해당 모듈이 담당하는 역할이 너무 크다는 뜻</li></ul></li><li>너무 많다<ul><li>모듈이 너무 많아서 관리 불능인 상태</li><li>모듈이 크다는 이유로 지나치게 분해해서는 안 된다</li></ul></li><li>이름이 맞지 않는다<ul><li>이름과 실제 코드가 맞지 않는 상태</li><li>이름은 중요하다</li></ul></li></ul></li></ul></li><li>기술적 부채<ul><li>문제 있는 코드는 &#x27;빚&#x27;이다</li><li>프로그래밍의 2가지 길: 시간이 좀 걸리더라도 깨끗한 코드 or 신속하지만 지저분한 코드</li><li>신속하고 지저분한 코드를 선택한다면 소프트웨어는 이른바 부채를 떠안는 셈이되는데 이를 기술적 부채라고 부른다</li><li>기술적 부채는 코드에서 수정하기 어렵고 이해하기 어려운, 문제 있는 지저분한 코드 부분을 뜻한다</li></ul></li><li>프로그래머의 3대 미덕<ul><li>태만<ul><li>전체의 노력을 줄이기 위해 수고를 아끼지 않는 기질</li><li>나중에 모두가 편해지도록 지금 유용한 코드를 작성한다</li><li>반복 업무를 시스템화하자</li><li>수작업에 관해서는 코드를 작성하고 툴을 만들어서 자동화 한다</li></ul></li><li>성급<ul><li>컴퓨터가 놀고 있는 것에 분노를 느끼는 기질</li><li>일어날 수 있는 문제를 상정해서 업무를 하자</li></ul></li><li>오만<ul><li>천벌을 받을 정도로 넘치는 자존심을 지닌 기질</li><li>높은 자존심을 갖고 남에게 내놓아도 부끄럽지 않은 코드를 작성한다</li><li>남에게 부끄럽지 않게끔 작업하고 보수하자</li></ul></li></ul></li><li>보이 스카우트 규칙<ul><li>코드는 자기가 왔을 때보다 깨끗이 하고 나서 자리를 떠나야 한다</li><li>처음 코드를 작성한 사람이 누구인지와는 상관없이, 조금씩이라도 코드를 개선하려는 노력을 계속해야 한다</li></ul></li><li>성능 튜닝에 관한 금언<ul><li>프로그래밍에서는 빠른 코드보다 우선 바르고 읽기 쉬운 것에 주안점을 둔 좋은 코드를 작성하는 데 노력해야 한다</li></ul></li><li>비자아적 프로그래밍<ul><li>프로그래밍할 때는 자아를 떨쳐 버려야 한다</li><li>자만과 자존심을 버리고 동료에게 협력을 구하도록 한다</li><li>자신이 작성한 코드를 적극적으로 등료에게 보여주면서 개선점을 지적해 달라고 한다</li><li>비자아적 프로그래밍의 십계<ul><li>자기 자신도 실수를 저지른다는 점을 이해하고 받아들인다</li><li>작성한 코드는 자기 자신이 아니다</li><li>아무리 끝까지 간 것 같아도 위에는 그 이상이 있다</li><li>상담 없이 코드를 재작성하지 않는다</li><li>자기보다 기술이 떨어지는 사람에게도 존경과 경의, 인내를 갖고 대한다</li><li>세상에서 유일하게 변하지 않는 것은 변한다는 사실뿐이다</li><li>진정한 권위는 지위가 아니라 지식에서 생겨난다</li><li>신념을 위해 싸운다. 다만 패배는 깨끗이 수용한다</li><li>방에 틀어박혀 있어서는 안 된다</li><li>사람에게는 관대하고 코드에는 엄격하게, 사람이 아닌 코드를 비평한다</li></ul></li></ul></li><li>한 걸음씩 조금씩<ul><li>프로그래밍은 한 번에 작은 하나만을 수행한다</li><li>하나씩 조금씩 단차가 작은 계단을 올라가듯이 작업한다</li><li>절대 한 번에 여러 가지 작업을 상대하지 말고 하나씩 처리한다</li></ul></li><li>TMTOWTDI (There&#x27;s more than one way to do it 방법은 하나가 아니다)<ul><li>다른 사람이 사용할 툴을 설계할 때는 달성하고자 하는 것의 수단을 여러 개 준비한다</li><li>여기서 말하는 툴이란 프로그래밍 언어나 DSL, API를 가리킨다</li></ul></li><li>예광탄<ul><li>예광탄이란 빛을 발산함으로써 탄도의 궤적을 알 수 있게끔 만들어진 탄환을 말한다</li><li>예광탄은 즉시 피드백을 가져다 준다</li><li>프로그래밍에서의 예광탄이란 우선적으로 검증하고 싶은 부분을 선행적으로 프로그래밍하는 것이다</li></ul></li><li>계약에 의한 설계<ul><li>각각의 함수는 뭔가의 작업을 수행하는 것이다</li></ul></li><li>방어적 프로그래밍<ul><li>이렇게 될 것이다라고 결정짓지 말고 프로그래밍한다</li><li>자동차의 방어 운전과 같은 사고방식이다</li><li>외부 소스에서의 데이터 입력값을 확인한다</li><li>함수의 입력 파라미터값을 확인한다</li></ul></li><li>개밥 먹기<ul><li>자기가 개발한 소프트웨어는 본인이 직접 사용해 봐야 한다</li></ul></li><li>고무 오리<ul><li>고무 오리는 일종의 디버깅 기법이다</li><li>프로그래밍 중에 발생한 문제, 혹은 문제를 품고 있는 코드를 누군가에게 설명한다</li><li>그러다 보면 문제의 원인을 스스로 깨닫고 자체 해결할 수 있을 때가 있다</li></ul></li><li>컨텍스트<ul><li>컨텍스트란 주위의 상황이나 배경을 뜻하며, 문맥이라고도 한다</li><li>코드의 읽고 쓰기에 사용</li><li>생각의 도구로 사용</li></ul></li><li>브룩스의 법칙<ul><li>일정이 늦어지고 있어 후반에 사람을 추가하면 오히려 지연이 한층 더 초래된다</li></ul></li><li>콘웨이의 법칙<ul><li>소프트웨어의 구조, 즉 아키텍처는 그것을 만든 조직을 반영한다</li></ul></li><li>깨진 유리창 법칙<ul><li>나쁜 설계, 잘못된 의사 결정, 나쁜 코드를 방치하면 그것이 아무리 작은 것이라도 소프트웨어 전체를 매우 단기간에 부패시킨다</li></ul></li><li>엔트로피 증가의 법칙<ul><li>엔트로피란 물리학 용어로 무질서한 정도를 나타낸다</li><li>코드는 그대로 두면 한계를 뛰어넘을 만큼 무질서함이 증대된다</li><li>코드의 부패 징후<ul><li>경직됨<ul><li>변경하기 어렵다</li></ul></li><li>깨지기 쉬움<ul><li>단 하나의 변경으로 인해 다른 많은 부분이 망가져 버리는 정도</li></ul></li><li>이식성 없음<ul><li>다른 환경으로 이식하기 어렵다</li></ul></li><li>다루기 어려움<ul><li>코드를 다루기 어려움과 개발 환경을 다루기 어려움이 있다</li></ul></li><li>복잡함<ul><li>불필요한 요소가 많음을 뜻한다</li></ul></li><li>반복<ul><li>똑같은 코드가 어러 번 반복해서 나타난다는 뜻이다</li></ul></li><li>불투명함<ul><li>코드를 이해하기 어렵다</li></ul></li></ul></li></ul></li><li>80:10:10의 법칙<ul><li>소프트웨어를 개발하면 사용자가 요구하는 것의 80%는 놀랄 만큼 단기간에 실현할 수 있다</li><li>그러나 나머지 20% 중 10%는 실현은 가능하지만 상당한 노력이 필요하다</li><li>더욱이 나머지 10%는 완전히 실현이 불가능하다</li></ul></li><li>조슈아 나무의 법칙<ul><li>사람은 이름을 아는 순간 그것이 보인다. 반대로 이름이 없으면(모르면) 그것은 보이지 않는다</li></ul></li><li>세컨드 시스템 증후군<ul><li>첫번째 버전을 배포한 프로그래머가 설계한 두번째 버전 소프트웨어는 해당 프로그래머가 설게하는 가장 위험한 버전이다</li><li>두 번째 버전에는 기능을 너무 잔뜩 집어넣어 품질이 나쁘고, 기능의 사용성도 떨어지는 경향이 있다</li></ul></li><li>수레바퀴의 재발명<ul><li>이미 세상에 존재하는 수레바퀴를 일부러 수고를 들여 다시 한번 발명하는 것과 같은 쓸데없는 작업</li><li>수레바퀴의 재발명을 피하고 본래 해야 할 작업에 주력하자</li><li>코드를 작성하기 전에 똑같은 기능이 표준 라이브러리에 없는지, 오픈 소스 라이브러리에 없는지, 표준 프로토콜이 없는지를 반드시 확인하도록 한다</li><li>수레바퀴를 재발명해야 될때<ul><li>비즈니스 목적</li><li>학습 목적</li></ul></li></ul></li><li>야크의 털깍기<ul><li>어떤 문제를 해결하려고 봤더니 다른 문제가 계속 나와 좀처럼 몸통, 즉 기본 문제(의 해결)에 도달하지 못하는 것이다</li><li>야크의 털깍기는 기본적으로 피해 가야 한다</li></ul></li></ul></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/programming">programming</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/karais89/karais89.github.io/tree/main/my-website/blog/2018-10-26-the-pinnacle-of-programming-summary/index.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>페이지 편집</a></div></footer></article><div></div><nav class="pagination-nav docusaurus-mt-lg" aria-label="블로그 게시물 탐색"><a class="pagination-nav__link pagination-nav__link--prev" href="/2018/10/26/the-pinnacle-of-programming"><div class="pagination-nav__sublabel">이전 게시물</div><div class="pagination-nav__label">[리뷰] 프로그래밍의 정석</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/2018/10/20/book-list"><div class="pagination-nav__sublabel">다음 게시물</div><div class="pagination-nav__label">소유 서적 목록</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#책에서의-용어-설명" class="table-of-contents__link toc-highlight">책에서의 용어 설명</a></li><li><a href="#책에서의-참고-서적" class="table-of-contents__link toc-highlight">책에서의 참고 서적</a></li><li><a href="#원리-원칙-리스트" class="table-of-contents__link toc-highlight">원리 원칙 리스트</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://twitter.com/karais89" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/">Blog</a></li><li class="footer__item"><a href="https://github.com/karais89" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.6c5e61e9.js"></script>
<script src="/assets/js/main.6d90619a.js"></script>
</body>
</html>