"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[30702],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var i=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=i.createContext({}),h=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=h(e.components);return i.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},f=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),f=h(n),u=r,g=f["".concat(s,".").concat(u)]||f[u]||p[u]||o;return n?i.createElement(g,a(a({ref:t},c),{},{components:n})):i.createElement(g,a({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,a=new Array(o);a[0]=f;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,a[1]=l;for(var h=2;h<o;h++)a[h]=n[h];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}f.displayName="MDXCreateElement"},47758:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>h});var i=n(87462),r=(n(67294),n(3905));const o={title:"[Codewars #47] Alphabet war - Wo lo loooooo priests join the war (5kyu)",authors:["karais89"],tags:["codewars","kata"]},a=void 0,l={permalink:"/2019/01/24/codewars-Alphabet-war-Wo-lo-loooooo-priests-join-the-war",editUrl:"https://github.com/karais89/karais89.github.io/tree/main/my-website/blog/2019-01-24-codewars-Alphabet-war-Wo-lo-loooooo-priests-join-the-war/index.md",source:"@site/blog/2019-01-24-codewars-Alphabet-war-Wo-lo-loooooo-priests-join-the-war/index.md",title:"[Codewars #47] Alphabet war - Wo lo loooooo priests join the war (5kyu)",description:"Instructions",date:"2019-01-24T00:00:00.000Z",formattedDate:"2019\ub144 1\uc6d4 24\uc77c",tags:[{label:"codewars",permalink:"/tags/codewars"},{label:"kata",permalink:"/tags/kata"}],readingTime:6.1,hasTruncateMarker:!1,authors:[{name:"karais89",title:"Game Developer",url:"https://github.com/karais89",imageURL:"https://github.com/karais89.png",key:"karais89"}],frontMatter:{title:"[Codewars #47] Alphabet war - Wo lo loooooo priests join the war (5kyu)",authors:["karais89"],tags:["codewars","kata"]},prevItem:{title:"[Codewars #52] Ones and Zeros (7kyu)",permalink:"/2019/01/25/codewars-Ones-and-Zeros"},nextItem:{title:"[Codewars #48] Grasshopper - Summation (8kyu)",permalink:"/2019/01/24/codewars-Grasshopper-Summation"}},s={authorsImageUrls:[void 0]},h=[{value:"Instructions",id:"instructions",level:2},{value:"My Solution",id:"my-solution",level:2},{value:"Best Practices 1",id:"best-practices-1",level:2},{value:"Best Practices 2",id:"best-practices-2",level:2}],c={toc:h};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"instructions"},"Instructions"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.codewars.com/kata/alphabet-war-wo-lo-loooooo-priests-join-the-war/train/csharp"},"\ub9c1\ud06c")),(0,r.kt)("p",null,"There is a war and nobody knows - the alphabet war!\nThere are two groups of hostile letters. The tension between left side letters and right side letters was too high and the war began. The letters have discovered a new unit - a priest with Wo lo looooooo power."),(0,r.kt)("p",null,"Task\nWrite a function that accepts fight string consists of only small letters and return who wins the fight. When the left side wins return Left side wins!, when the right side wins return Right side wins!, in other case return Let's fight again!."),(0,r.kt)("p",null,"The left side letters and their power:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," w - 4\n p - 3\n b - 2\n s - 1\n t - 0 (but it's priest with Wo lo loooooooo power)\n")),(0,r.kt)("p",null,"The right side letters and their power:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," m - 4\n q - 3\n d - 2\n z - 1\n j - 0 (but it's priest with Wo lo loooooooo power)\n")),(0,r.kt)("p",null,"The other letters don't have power and are only victims.\nThe priest units t and j change the adjacent letters from hostile letters to friendly letters with the same power."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mtq => wtp\nwjs => mjz\n")),(0,r.kt)("p",null,"A letter with adjacent letters j and t is not converted i.e.:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"tmj => tmj\njzt => jzt\n")),(0,r.kt)("p",null,"The priests (j and t) do not convert the other priests ( jt => jt)."),(0,r.kt)("p",null,"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'AlphabetWar("z") //=> "z" => "Right side wins!"\nAlphabetWar("tz") //=> "ts" => "Left side wins!"\nAlphabetWar("jz") //=> "jz" => "Right side wins!"\nAlphabetWar("zt") //=> "st" => "Left side wins!"\nAlphabetWar("azt") //=> "ast" => "Left side wins!"\nAlphabetWar("tzj") //=> "tzj" => "Right side wins!"\n')),(0,r.kt)("p",null,"Alphabet war Collection"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Alphabet war"),(0,r.kt)("li",{parentName:"ul"},"Alphabet war - airstrike - letters massacre"),(0,r.kt)("li",{parentName:"ul"},"Alphabet wars - reinforces massacre"),(0,r.kt)("li",{parentName:"ul"},"Alphabet wars - nuclear strike"),(0,r.kt)("li",{parentName:"ul"},"Alphabet war - Wo lo loooooo priests join the war")),(0,r.kt)("h2",{id:"my-solution"},"My Solution"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"}," using System;\n using System.Text;\n using System.Collections.Generic;\n\n public class Kata\n {\n    public static readonly Dictionary<char, int> leftSideLetters = new Dictionary<char, int>()\n    {\n        { 'w', 4 }, { 'p', 3 }, { 'b', 2 }, { 's', 1 }\n    };\n\n    public static readonly Dictionary<char, int> rightSideLetters = new Dictionary<char, int>()\n    {\n        { 'm', 4 }, { 'q', 3 }, { 'd', 2 }, { 'z', 1 }\n    };\n\n    public static char RightToLeftLetter(char ch)\n    {\n      if (rightSideLetters.ContainsKey(ch))\n      {\n        int score = rightSideLetters[ch];\n        foreach (var left in leftSideLetters)\n        {\n          if (left.Value == score)\n          {\n            return left.Key;\n          }\n        }\n      }\n\n      return ch;\n    }\n\n    public static char LeftToRightLetter(char ch)\n    {\n      if (leftSideLetters.ContainsKey(ch))\n      {\n        int score = leftSideLetters[ch];\n        foreach (var right in rightSideLetters)\n        {\n          if (right.Value == score)\n          {\n            return right.Key;\n          }\n        }\n      }\n\n      return ch;\n    }\n\n    public static string AlphabetWar(string fight)\n    {\n        int leftScore = 0;\n        int rightScore = 0;\n\n        //Console.WriteLine(\"fight: \" + fight);\n\n        StringBuilder convFight = new StringBuilder(fight);\n        // priest char check\n        for (int i = 0; i < convFight.Length; i++)\n        {\n          // left side priest\n          if (convFight[i] == 't')\n          {\n            bool isTwoLeftPriest = (i - 2 >= 0 && convFight[i - 2] == 'j');\n            if (!isTwoLeftPriest)\n            {\n              // left alpha change\n              if (i - 1 >= 0)\n              {\n                convFight[i - 1] = RightToLeftLetter(convFight[i - 1]);\n              }\n            }\n\n            bool isTwoRightPriest = (i + 2 <= convFight.Length - 1 && convFight[i + 2] == 'j');\n            if (!isTwoRightPriest)\n            {\n              // right alpha change\n              if (i + 1 <= convFight.Length - 1)\n              {\n                convFight[i + 1] = RightToLeftLetter(convFight[i + 1]);\n              }\n            }\n          }\n\n          // right side priest\n          if (convFight[i] == 'j')\n          {\n            bool isTwoLeftPriest = (i - 2 >= 0 && convFight[i - 2] == 't');\n            if (!isTwoLeftPriest)\n            {\n              // left alpha change\n              if (i - 1 >= 0)\n              {\n                convFight[i - 1] = LeftToRightLetter(convFight[i - 1]);\n              }\n            }\n\n            bool isTwoRightPriest = (i + 2 <= convFight.Length - 1 && convFight[i + 2] == 't');\n            if (!isTwoRightPriest)\n            {\n              // right alpha change\n              if (i + 1 <= convFight.Length - 1)\n              {\n                convFight[i + 1] = LeftToRightLetter(convFight[i + 1]);\n              }\n            }\n          }\n        }\n\n        // left and right score diff\n        for (int i = 0; i < convFight.Length; i++)\n        {\n          char ch = convFight[i];\n          if (leftSideLetters.ContainsKey(ch))\n          {\n            leftScore += leftSideLetters[ch];\n          }\n\n          if (rightSideLetters.ContainsKey(ch))\n          {\n            rightScore += rightSideLetters[ch];\n          }\n        }\n\n        if (leftScore > rightScore)\n        {\n          return \"Left side wins!\";\n        }\n        else if (leftScore < rightScore)\n        {\n          return \"Right side wins!\";\n        }\n        else\n        {\n          return \"Let's fight again!\";\n        }\n    }\n }\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\uc54c\ud30c\ubcb3 \uc804\uc7c1 \uc2dc\ub9ac\uc988."),(0,r.kt)("li",{parentName:"ul"},"\uac01 \uc54c\ud30c\ubcb3 \ub9c8\ub2e4 \uc810\uc218\uac00 \uc788\ub2e4."),(0,r.kt)("li",{parentName:"ul"},"t\uc640 j\ub294 \uc0c1\ub300 \uc54c\ud30c\ubcb3\uc744 \uc790\uae30 \uc54c\ud30c\ubcb3 \uc810\uc218\ub85c \ubcc0\uacbd\ud55c\ub2e4."),(0,r.kt)("li",{parentName:"ul"},"2\uce78 \uc606\uc758 priest\ub97c \ube44\uad50\ud558\ub294 \ubd80\ubd84\uc774 \uc911\ubcf5\ub418\ub294 \ubd80\ubd84\uacfc \uc4f8\ub370\uc5c6\uc774 \uae38\uc5b4\uc9c0\ub294 \ubd80\ubd84\uc774 \uc788\ub2e4.")),(0,r.kt)("h2",{id:"best-practices-1"},"Best Practices 1"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"using System.Collections.Generic;\npublic class Kata\n {\n        public enum Side\n        {\n            LeftSide,\n            RightSide,\n            NoSide\n        }\n\n        public static string AlphabetWar(string fight)\n        {\n            int pointDiff = 0;\n            Dictionary<char, int> leftPowers = new Dictionary<char, int>(){\n                {'w',4},\n                {'p',3},\n                {'b',2},\n                {'s',1},\n                {'t',0}\n            };\n            Dictionary<char, int> rightPowers = new Dictionary<char, int>(){\n                {'m',4},\n                {'q',3},\n                {'d',2},\n                {'z',1},\n                {'j',0}\n            };\n\n            for (int i = 0; i < fight.Length; i++)\n            {\n                int value = 0;\n                Side n1Wooloo = Side.NoSide;\n                Side n2Wooloo = Side.NoSide;\n\n                if (leftPowers.TryGetValue(fight[i], out value))\n                {\n                    if (value == 0) continue;\n\n                    value *= -1;\n\n                    findNeighborWooloos(i, leftPowers, rightPowers, fight, ref n1Wooloo, ref n2Wooloo);\n\n                    if (n1Wooloo == Side.RightSide && n2Wooloo != Side.LeftSide || n2Wooloo == Side.RightSide && n1Wooloo != Side.LeftSide)\n                        value *= -1;\n                }\n                else if (rightPowers.TryGetValue(fight[i], out value))\n                {\n                    if (value == 0) continue;\n\n                    findNeighborWooloos(i, leftPowers, rightPowers, fight, ref n1Wooloo, ref n2Wooloo);\n\n                    if (n1Wooloo == Side.LeftSide && n2Wooloo != Side.RightSide || n2Wooloo == Side.LeftSide && n1Wooloo != Side.RightSide)\n                        value *= -1;\n                }\n\n                pointDiff += value;\n            }\n\n            if (pointDiff > 0) { return \"Right side wins!\"; }\n            if (pointDiff < 0) { return \"Left side wins!\"; }\n            return \"Let's fight again!\";\n        }\n\n        public static void findNeighborWooloos(int i, Dictionary<char, int> leftPowers, Dictionary<char, int> rightPowers, string fight, ref Side n1Wooloo, ref Side n2Wooloo)\n        {\n            int tempVal;\n            if (i > 0)\n            {\n                if (leftPowers.TryGetValue(fight[i - 1], out tempVal))\n                {\n                    if (tempVal == 0) n1Wooloo = Side.LeftSide;\n                }\n                else if (rightPowers.TryGetValue(fight[i - 1], out tempVal))\n                {\n                    if (tempVal == 0) n1Wooloo = Side.RightSide;\n                }\n            }\n            if (i < fight.Length - 1)\n            {\n                if (leftPowers.TryGetValue(fight[i + 1], out tempVal))\n                {\n                    if (tempVal == 0) n2Wooloo = Side.LeftSide;\n                }\n                else if (rightPowers.TryGetValue(fight[i + 1], out tempVal))\n                {\n                    if (tempVal == 0) n2Wooloo = Side.RightSide;\n                }\n            }\n        }\n }\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\ubb38\uc790 \uc790\uccb4\ub97c \ubcc0\uacbd \ud558\ub294 \uc791\uc5c5\uc744 \ud558\uc9c0 \uc54a\ub294\ub2e4."),(0,r.kt)("li",{parentName:"ul"},"\ubb38\uc790\ub97c \ube44\uad50\ud558\uace0 \uc606\uc774 priest\uc77c \uacbd\uc6b0 \uc810\uc218\ub9cc \ubcc0\uacbd \ud574\uc900\ub2e4.")),(0,r.kt)("h2",{id:"best-practices-2"},"Best Practices 2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},' using System.Linq;\n using System.Text.RegularExpressions;\n public class Kata\n {\n    public static string AlphabetWar(string fight)\n    {\n        string power = "wpbs_zdqm";\n        fight = new Regex(@"(?<!t)[wpbs](?=j)|(?<=j)[wpbs](?!t)|(?<!j)[zdqm](?=t)|(?<=t)[zdqm](?!j)").Replace(fight, x => ""+ power[8 - power.IndexOf(x.Value)]);\n        int result = fight.Aggregate(0, (a, b) => a + (power.IndexOf(b) == -1 ? 0 : power.IndexOf(b) - 4)); //\n        return result == 0 ? "Let\'s fight again!" : $"{(result < 0 ? "Left":"Right")} side wins!";\n    }\n }\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\uc815\uaddc\ud45c\ud604\uc2dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uac04\ub2e8\ud558\uac8c \ud574\uacb0")))}p.isMDXComponent=!0}}]);